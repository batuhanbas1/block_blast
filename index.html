<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Block Blast - Classic Dark</title>
    <style>
        /* Görseldeki fonta benzer, okunaklı ve yuvarlak hatlı bir font */
        @import url('https://fonts.googleapis.com/css2?family=Varela+Round&display=swap');

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            /* Görseldeki Koyu Lacivert Arka Plan */
            background-color: #2b3648; 
            font-family: 'Varela Round', sans-serif;
            touch-action: none;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: 500px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* --- HEADER (Görseldeki Gibi) --- */
        #header {
            width: 90%;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr; /* Sol, Orta, Sağ */
            align-items: center;
            padding-top: 50px;
            padding-bottom: 20px;
            z-index: 10;
        }

        /* Sol Taraf: Rekor */
        .header-left {
            display: flex;
            align-items: center;
            gap: 8px;
            justify-content: flex-start;
        }

        .crown-icon {
            width: 24px;
            height: 24px;
            fill: #f2c94c; /* Altın Sarısı */
        }

        #high-score-val {
            color: #f2c94c;
            font-size: 1.2rem;
            font-weight: 700;
        }

        /* Orta Taraf: Skor */
        .header-center {
            display: flex;
            justify-content: center;
        }

        #score {
            color: #ffffff;
            font-size: 2.5rem; /* Görseldeki gibi büyük */
            font-weight: 700;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        /* Sağ Taraf: Ayarlar */
        .header-right {
            display: flex;
            justify-content: flex-end;
        }

        .settings-icon {
            width: 28px;
            height: 28px;
            fill: #8da6c9; /* Soluk mavi/gri */
            cursor: pointer;
            transition: transform 0.2s;
        }
        .settings-icon:hover { transform: rotate(90deg); fill: #fff; }

        canvas {
            display: block;
            border-radius: 6px; /* Hafif yuvarlak köşe */
            z-index: 5;
            /* Grid alanı arka planı */
            background-color: #202a3a; 
            box-shadow: inset 0 0 20px rgba(0,0,0,0.2);
            touch-action: none;
            margin-top: 10px;
        }

        /* --- GAME OVER --- */
        #game-over {
            position: absolute;
            inset: 0;
            background: rgba(32, 42, 58, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        #game-over.active { opacity: 1; pointer-events: all; }

        .go-title {
            font-size: 2.5rem;
            color: #fff;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .go-score {
            font-size: 1.2rem;
            color: #8da6c9;
            margin-bottom: 30px;
        }
        
        .go-score span { color: #f2c94c; font-size: 1.8rem; font-weight: 700; }

        .btn-restart {
            background: #3498db;
            border: none;
            padding: 15px 50px;
            font-size: 1.1rem;
            color: white;
            border-radius: 8px;
            font-family: 'Varela Round', sans-serif;
            font-weight: 700;
            cursor: pointer;
            box-shadow: 0 4px 0 #2980b9; /* 3D Buton hissi */
            transition: all 0.1s;
        }
        
        .btn-restart:active { transform: translateY(4px); box-shadow: none; }

    </style>
</head>
<body>

    <div id="game-container">
        <div id="header">
            <div class="header-left">
                <svg class="crown-icon" viewBox="0 0 24 24">
                    <path d="M5 16L3 5L8.5 10L12 4L15.5 10L21 5L19 16H5M19 19C19 19.6 18.6 20 18 20H6C5.4 20 5 19.6 5 19V18H19V19Z" />
                </svg>
                <div id="high-score-val">0</div>
            </div>

            <div class="header-center">
                <div id="score">0</div>
            </div>

            <div class="header-right">
                <svg class="settings-icon" viewBox="0 0 24 24">
                    <path d="M12,15.5A3.5,3.5 0 0,1 8.5,12A3.5,3.5 0 0,1 12,8.5A3.5,3.5 0 0,1 15.5,12A3.5,3.5 0 0,1 12,15.5M19.43,12.97C19.47,12.65 19.5,12.33 19.5,12C19.5,11.67 19.47,11.34 19.43,11L21.54,9.37C21.73,9.22 21.78,8.95 21.66,8.73L19.66,5.27C19.54,5.05 19.27,4.96 19.05,5.05L16.56,6.05C16.04,5.66 15.5,5.32 14.87,5.07L14.5,2.42C14.46,2.18 14.25,2 14,2H10C9.75,2 9.54,2.18 9.5,2.42L9.13,5.07C8.5,5.32 7.96,5.66 7.44,6.05L4.95,5.05C4.73,4.96 4.46,5.05 4.34,5.27L2.34,8.73C2.21,8.95 2.27,9.22 2.46,9.37L4.57,11C4.53,11.34 4.5,11.67 4.5,12C4.5,12.33 4.53,12.65 4.57,12.97L2.46,14.63C2.27,14.78 2.21,15.05 2.34,15.27L4.34,18.73C4.46,18.95 4.73,19.03 4.95,18.95L7.44,17.94C7.96,18.34 8.5,18.68 9.13,18.93L9.5,21.58C9.54,21.82 9.75,22 10,22H14C14.25,22 14.46,21.82 14.5,21.58L14.87,18.93C15.5,18.67 16.04,18.34 16.56,17.94L19.05,18.95C19.27,19.03 19.54,18.95 19.66,18.73L21.66,15.27C21.78,15.05 21.73,14.78 21.54,14.63L19.43,12.97Z" />
                </svg>
            </div>
        </div>

        <canvas id="gameCanvas"></canvas>

        <div id="game-over">
            <div class="go-title">Game Over</div>
            <div class="go-score">Score: <span id="final-score">0</span></div>
            <button class="btn-restart" onclick="restartGame()">Try Again</button>
        </div>
    </div>

    <script>
        // --- SES SİSTEMİ (Basit ve Tok Sesler) ---
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioCtx = new AudioContext();
        
        const Sounds = {
            playTone: (freq, type, duration, vol = 0.1) => {
                if (audioCtx.state === 'suspended') audioCtx.resume();
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
                gain.gain.setValueAtTime(vol, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + duration);
            },
            
            pop: () => Sounds.playTone(200, 'square', 0.1, 0.05), // Tok yerleştirme sesi
            clear: (combo) => {
                const base = 400 + (combo * 50);
                Sounds.playTone(base, 'sawtooth', 0.1, 0.08);
                setTimeout(() => Sounds.playTone(base + 100, 'sawtooth', 0.2, 0.08), 50);
            },
            gameOver: () => {
                Sounds.playTone(150, 'sawtooth', 0.5, 0.2);
                setTimeout(() => Sounds.playTone(100, 'sawtooth', 1.0, 0.2), 300);
            }
        };

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        const scoreEl = document.getElementById('score');
        const highScoreEl = document.getElementById('high-score-val');
        const gameOverScreen = document.getElementById('game-over');
        const finalScoreEl = document.getElementById('final-score');

        // --- AYARLAR ---
        const GRID_SIZE = 8;
        let CELL_SIZE = 40;
        const GAP = 2; // Görseldeki gibi çok ince boşluk
        const BOARD_OFFSET_Y = 20;
        
        // --- RENK PALETİ (Görselden Esinlenilmiş) ---
        const COLORS = {
            gridEmpty: '#202a3a', // Koyu Grid Arka Planı
            blocks: [
                '#E74C3C', // Kırmızı
                '#F39C12', // Turuncu (Görseldeki gibi)
                '#F1C40F', // Sarı
                '#2ECC71', // Yeşil
                '#3498DB', // Mavi
                '#9B59B6', // Mor
                '#E67E22', // Koyu Turuncu
                '#1ABC9C'  // Turkuaz
            ]
        };

        const SHAPES = [
            [[1]], [[1, 1]], [[1], [1]], [[1, 1, 1]], [[1], [1], [1]], 
            [[1, 1], [1, 1]], [[1, 1, 1], [0, 1, 0]], [[0, 1, 0], [1, 1, 1]], 
            [[1, 0], [1, 0], [1, 1]], [[0, 1], [0, 1], [1, 1]], 
            [[1, 1, 0], [0, 1, 1]], [[0, 1, 1], [1, 1, 0]], 
            [[1, 1, 1, 1]], [[1, 1, 1], [1, 0, 0]], [[1, 1, 1], [0, 0, 1]]
        ];

        // --- DURUM YÖNETİMİ ---
        let grid = [];
        let debris = [];
        let dockPieces = [];
        let draggedPiece = null;
        let score = 0;
        let highScore = localStorage.getItem('blockBlastClassicHS') || 0;
        let isGameOver = false;
        let canvasWidth, canvasHeight;
        let boardX, boardY, boardWidth;

        function resize() {
            const container = document.getElementById('game-container');
            canvasWidth = container.clientWidth;
            canvasHeight = container.clientHeight;
            
            const dpr = window.devicePixelRatio || 1;
            canvas.width = canvasWidth * dpr;
            canvas.height = canvasHeight * dpr;
            ctx.scale(dpr, dpr);
            canvas.style.width = canvasWidth + 'px';
            canvas.style.height = canvasHeight + 'px';

            const margin = 20;
            const availableWidth = canvasWidth - (margin * 2);
            CELL_SIZE = Math.floor((availableWidth - (GAP * (GRID_SIZE - 1))) / GRID_SIZE);
            boardWidth = (CELL_SIZE * GRID_SIZE) + (GAP * (GRID_SIZE - 1));
            boardX = (canvasWidth - boardWidth) / 2;
            boardY = BOARD_OFFSET_Y;

            updateDockPositions();
        }

        function init() {
            if(audioCtx.state === 'suspended') audioCtx.resume();

            grid = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null));
            score = 0;
            isGameOver = false;
            debris = [];
            
            updateUI();
            gameOverScreen.classList.remove('active');
            
            spawnPieces();
            resize();
            requestAnimationFrame(gameLoop);
        }

        function spawnPieces() {
            dockPieces = [];
            for (let i = 0; i < 3; i++) {
                const shape = SHAPES[Math.floor(Math.random() * SHAPES.length)];
                const color = COLORS.blocks[Math.floor(Math.random() * COLORS.blocks.length)];
                dockPieces.push({
                    shape: JSON.parse(JSON.stringify(shape)),
                    color: color,
                    x: 0, y: 0, width: 0, height: 0,
                    scale: 0.6, isDragging: false, targetScale: 0.6,
                    baseX: 0, baseY: 0
                });
            }
            updateDockPositions();
            checkGameOver();
        }

        function updateDockPositions() {
            const dockY = boardY + boardWidth + 40;
            const pieceSpacing = canvasWidth / 3;
            dockPieces.forEach((p, index) => {
                if (!p) return;
                p.baseX = (pieceSpacing * index) + (pieceSpacing / 2);
                p.baseY = dockY + 60;
                if (!p.isDragging) { p.x = p.baseX; p.y = p.baseY; }
            });
        }

        // --- GÖRSEL FONKSİYONLAR (CLASSIC BEVEL STYLE) ---
        
        // Rengi açma/koyulaştırma fonksiyonu
        function shadeColor(color, percent) {
            let R = parseInt(color.substring(1,3),16);
            let G = parseInt(color.substring(3,5),16);
            let B = parseInt(color.substring(5,7),16);
            R = parseInt(R * (100 + percent) / 100);
            G = parseInt(G * (100 + percent) / 100);
            B = parseInt(B * (100 + percent) / 100);
            R = (R<255)?R:255; G = (G<255)?G:255; B = (B<255)?B:255;
            let RR = ((R.toString(16).length==1)?"0"+R.toString(16):R.toString(16));
            let GG = ((G.toString(16).length==1)?"0"+G.toString(16):G.toString(16));
            let BB = ((B.toString(16).length==1)?"0"+B.toString(16):B.toString(16));
            return "#"+RR+GG+BB;
        }

        function drawBlock(ctx, x, y, size, color, alpha = 1.0, scale = 1.0) {
            ctx.globalAlpha = alpha;
            const center = size/2;
            
            ctx.save();
            ctx.translate(x + center, y + center);
            ctx.scale(scale, scale);
            ctx.translate(-center, -center);

            // 1. Ana Renk (Flat)
            ctx.fillStyle = color;
            ctx.fillRect(0, 0, size, size);

            // 2. Bevel Efekti (Görseldeki gibi 3D hissi)
            const lightColor = "rgba(255,255,255,0.3)";
            const darkColor = "rgba(0,0,0,0.2)";
            const bevelSize = size * 0.15; // Kenar kalınlığı

            // Üst ve Sol (Aydınlık)
            ctx.fillStyle = lightColor;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(size, 0);
            ctx.lineTo(size - bevelSize, bevelSize);
            ctx.lineTo(bevelSize, bevelSize);
            ctx.lineTo(bevelSize, size - bevelSize);
            ctx.lineTo(0, size);
            ctx.closePath();
            ctx.fill();

            // Alt ve Sağ (Gölge)
            ctx.fillStyle = darkColor;
            ctx.beginPath();
            ctx.moveTo(size, size);
            ctx.lineTo(0, size);
            ctx.lineTo(bevelSize, size - bevelSize);
            ctx.lineTo(size - bevelSize, size - bevelSize);
            ctx.lineTo(size - bevelSize, bevelSize);
            ctx.lineTo(size, 0);
            ctx.closePath();
            ctx.fill();

            // 3. İç Kısım (Hafif bir iç kare)
            ctx.fillStyle = color;
            ctx.fillRect(bevelSize, bevelSize, size - bevelSize*2, size - bevelSize*2);

            ctx.restore();
            ctx.globalAlpha = 1.0;
        }

        // --- OYUN MANTIĞI ---

        let isInputDown = false, dragOffsetY = 0;

        function handleInputStart(x, y) {
            if (isGameOver) return;
            if (audioCtx.state === 'suspended') audioCtx.resume();
            
            isInputDown = true;
            for (let p of dockPieces) {
                if (!p) continue;
                if (Math.abs(x - p.x) < 70 && Math.abs(y - p.y) < 70) {
                    draggedPiece = p;
                    draggedPiece.isDragging = true;
                    draggedPiece.targetScale = 1.0; // Ele alınca orjinal boyutuna gelir
                    dragOffsetY = -80; // Parmağın biraz üstünde dursun
                    draggedPiece.x = x;
                    draggedPiece.y = y + dragOffsetY;
                    if(navigator.vibrate) navigator.vibrate(10);
                    Sounds.pop();
                    break;
                }
            }
        }

        function handleInputMove(x, y) {
            if (draggedPiece) { draggedPiece.x = x; draggedPiece.y = y + dragOffsetY; }
        }

        function handleInputEnd() {
            if (draggedPiece) {
                const gp = getGridPosFromScreen(draggedPiece.x, draggedPiece.y, draggedPiece.shape);
                if (gp && canPlace(draggedPiece.shape, gp.c, gp.r)) {
                    placePiece(draggedPiece, gp.c, gp.r);
                    const index = dockPieces.indexOf(draggedPiece);
                    dockPieces[index] = null;
                    if(navigator.vibrate) navigator.vibrate(15);
                    if (dockPieces.every(p => p === null)) spawnPieces();
                    else checkGameOver();
                } else {
                    draggedPiece.isDragging = false;
                    draggedPiece.targetScale = 0.6;
                    draggedPiece.x = draggedPiece.baseX;
                    draggedPiece.y = draggedPiece.baseY;
                }
                draggedPiece = null;
            }
            isInputDown = false;
        }

        function getGridPosFromScreen(px, py, shape) {
            const w = shape[0].length * CELL_SIZE;
            const h = shape.length * CELL_SIZE;
            const c = Math.round((px - w/2 - boardX) / (CELL_SIZE + GAP));
            const r = Math.round((py - h/2 - boardY) / (CELL_SIZE + GAP));
            return { c, r };
        }

        function canPlace(shape, c, r) {
            for (let y = 0; y < shape.length; y++) {
                for (let x = 0; x < shape[0].length; x++) {
                    if (shape[y][x] === 1) {
                        const gx = c + x, gy = r + y;
                        if (gx < 0 || gx >= GRID_SIZE || gy < 0 || gy >= GRID_SIZE) return false;
                        if (grid[gy][gx] !== null) return false;
                    }
                }
            }
            return true;
        }

        function placePiece(piece, c, r) {
            let blocksPlaced = 0;
            Sounds.pop();
            
            for (let y = 0; y < piece.shape.length; y++) {
                for (let x = 0; x < piece.shape[0].length; x++) {
                    if (piece.shape[y][x] === 1) {
                        grid[r + y][c + x] = piece.color;
                        blocksPlaced++;
                    }
                }
            }
            addScore(blocksPlaced * 10);
            checkLines();
        }

        function checkLines() {
            let linesCleared = [];
            for (let y = 0; y < GRID_SIZE; y++) {
                if (grid[y].every(cell => cell !== null)) linesCleared.push({type:'row', idx:y});
            }
            for (let x = 0; x < GRID_SIZE; x++) {
                let full = true;
                for (let y = 0; y < GRID_SIZE; y++) {
                    if (grid[y][x] === null) { full = false; break; }
                }
                if (full) linesCleared.push({type:'col', idx:x});
            }

            if (linesCleared.length > 0) {
                Sounds.clear(linesCleared.length);

                linesCleared.forEach(line => {
                    if(line.type === 'row') {
                        for(let x=0; x<GRID_SIZE; x++) {
                            createDebris(x * (CELL_SIZE + GAP) + boardX + CELL_SIZE/2, line.idx * (CELL_SIZE + GAP) + boardY + CELL_SIZE/2, grid[line.idx][x]);
                            grid[line.idx][x] = null;
                        }
                    } else {
                        for(let y=0; y<GRID_SIZE; y++) {
                            createDebris(line.idx * (CELL_SIZE + GAP) + boardX + CELL_SIZE/2, y * (CELL_SIZE + GAP) + boardY + CELL_SIZE/2, grid[y][line.idx]);
                            grid[y][line.idx] = null;
                        }
                    }
                });

                let points = linesCleared.length * 100;
                if (linesCleared.length > 1) points *= 1.5; // Çoklu satır bonusu
                addScore(Math.floor(points));
                if(navigator.vibrate) navigator.vibrate(linesCleared.length * 30);
            }
        }

        function checkGameOver() {
            const active = dockPieces.filter(p => p !== null);
            if (active.length === 0) return;
            
            let canMove = false;
            for (let p of active) {
                for (let y = 0; y < GRID_SIZE; y++) {
                    for (let x = 0; x < GRID_SIZE; x++) {
                        if (canPlace(p.shape, x, y)) { canMove = true; break; }
                    }
                    if (canMove) break;
                }
                if (canMove) break;
            }
            if (!canMove) {
                setTimeout(() => {
                    isGameOver = true;
                    Sounds.gameOver();
                    gameOverScreen.classList.add('active');
                    finalScoreEl.innerText = score;
                }, 800);
            }
        }

        function addScore(amt) {
            score += amt;
            scoreEl.innerText = score;
            if (score > highScore) {
                highScore = score;
                highScoreEl.innerText = highScore;
                localStorage.setItem('blockBlastClassicHS', highScore);
            }
        }
        function updateUI() { scoreEl.innerText = score; highScoreEl.innerText = highScore; }
        function restartGame() { init(); }

        // --- EFEKTLER (Basitleştirilmiş) ---
        function createDebris(x, y, color) {
            for(let i=0; i<4; i++) {
                debris.push({
                    x: x, y: y,
                    vx: (Math.random()-0.5) * 10,
                    vy: (Math.random()-0.5) * 10,
                    size: Math.random() * 8 + 4,
                    color: color,
                    life: 1.0,
                });
            }
        }

        // --- RENDER DÖNGÜSÜ ---
        function gameLoop() {
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);

            // GRID (Sabit, koyu zemin)
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const posX = boardX + x * (CELL_SIZE + GAP);
                    const posY = boardY + y * (CELL_SIZE + GAP);
                    
                    // Boş hücreleri çiz (Arka plan renginden biraz açık ama çok değil)
                    ctx.fillStyle = COLORS.gridEmpty; 
                    ctx.fillRect(posX, posY, CELL_SIZE, CELL_SIZE);

                    if (grid[y][x]) {
                        drawBlock(ctx, posX, posY, CELL_SIZE, grid[y][x]);
                    }
                }
            }

            // ÖNİZLEME (Ghost Piece)
            if (draggedPiece) {
                const gp = getGridPosFromScreen(draggedPiece.x, draggedPiece.y, draggedPiece.shape);
                if (gp && canPlace(draggedPiece.shape, gp.c, gp.r)) {
                    ctx.globalAlpha = 0.3;
                    for (let y = 0; y < draggedPiece.shape.length; y++) {
                        for (let x = 0; x < draggedPiece.shape[0].length; x++) {
                            if (draggedPiece.shape[y][x] === 1) {
                                const px = boardX + (gp.c + x) * (CELL_SIZE + GAP);
                                const py = boardY + (gp.r + y) * (CELL_SIZE + GAP);
                                ctx.fillStyle = draggedPiece.color;
                                ctx.fillRect(px, py, CELL_SIZE, CELL_SIZE);
                            }
                        }
                    }
                    ctx.globalAlpha = 1.0;
                }
            }

            // Patlama Efekti
            for(let i=debris.length-1; i>=0; i--) {
                const p = debris[i];
                p.x += p.vx; p.y += p.vy;
                p.life -= 0.05;
                if(p.life <= 0) { debris.splice(i, 1); continue; }
                
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x, p.y, p.size, p.size);
                ctx.globalAlpha = 1.0;
            }

            // Aşağıdaki Parçalar
            dockPieces.forEach(p => {
                if (!p) return;
                p.scale += (p.targetScale - p.scale) * 0.2;
                const blockSize = draggedPiece === p ? CELL_SIZE : 26; // Dock parçaları biraz daha küçük
                const gap = draggedPiece === p ? GAP : 2;
                const totalW = p.shape[0].length * (blockSize + gap);
                const totalH = p.shape.length * (blockSize + gap);
                const startX = p.x - (totalW / 2);
                const startY = p.y - (totalH / 2);

                for (let r = 0; r < p.shape.length; r++) {
                    for (let c = 0; c < p.shape[0].length; c++) {
                        if (p.shape[r][c] === 1) {
                            if (draggedPiece === p) {
                                drawBlock(ctx, startX + c*(blockSize+gap), startY + r*(blockSize+gap), blockSize, p.color, 0.9, 1.0);
                            } else {
                                drawBlock(ctx, startX + c*(blockSize+gap), startY + r*(blockSize+gap), blockSize, p.color, 1.0, 1.0);
                            }
                        }
                    }
                }
            });

            requestAnimationFrame(gameLoop);
        }

        // --- EVENTS ---
        window.addEventListener('resize', resize);
        
        canvas.addEventListener('mousedown', e => handleInputStart(e.offsetX, e.offsetY));
        window.addEventListener('mousemove', e => { if(isInputDown) {
            const r = canvas.getBoundingClientRect();
            handleInputMove(e.clientX - r.left, e.clientY - r.top);
        }});
        window.addEventListener('mouseup', handleInputEnd);

        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            const r = canvas.getBoundingClientRect();
            handleInputStart(e.touches[0].clientX - r.left, e.touches[0].clientY - r.top);
        }, {passive: false});
        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            if(isInputDown) {
                const r = canvas.getBoundingClientRect();
                handleInputMove(e.touches[0].clientX - r.left, e.touches[0].clientY - r.top);
            }
        }, {passive: false});
        window.addEventListener('touchend', handleInputEnd);

        window.onload = init;

    </script>
</body>
</html>