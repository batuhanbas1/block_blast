<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Block Blast - Pro Edition</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Varela+Round&display=swap');

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #2b3648; 
            font-family: 'Varela Round', sans-serif;
            touch-action: none;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: 500px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* --- HEADER --- */
        #header {
            width: 90%;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            align-items: center;
            padding-top: 50px;
            padding-bottom: 20px;
            z-index: 10;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 8px;
            justify-content: flex-start;
        }

        .crown-icon { width: 24px; height: 24px; fill: #f2c94c; }

        #high-score-val {
            color: #f2c94c;
            font-size: 1.2rem;
            font-weight: 700;
        }

        .header-center { display: flex; justify-content: center; }

        #score {
            color: #ffffff;
            font-size: 2.8rem;
            font-weight: 700;
            text-shadow: 0 4px 10px rgba(0,0,0,0.3);
            font-variant-numeric: tabular-nums; /* Sayıların titremesini engeller */
        }

        .header-right { display: flex; justify-content: flex-end; }
        .settings-icon { width: 28px; height: 28px; fill: #8da6c9; cursor: pointer; }

        canvas {
            display: block;
            border-radius: 6px;
            z-index: 5;
            background-color: #202a3a; 
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            touch-action: none;
            margin-top: 10px;
        }

        /* --- GAME OVER --- */
        #game-over {
            position: absolute;
            inset: 0;
            background: rgba(32, 42, 58, 0.96);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        #game-over.active { opacity: 1; pointer-events: all; }

        .go-title { font-size: 2.5rem; color: #fff; margin-bottom: 10px; font-weight: 700; }
        .go-score { font-size: 1.2rem; color: #8da6c9; margin-bottom: 30px; }
        .go-score span { color: #f2c94c; font-size: 1.8rem; font-weight: 700; }

        .btn-restart {
            background: #3498db;
            border: none;
            padding: 15px 50px;
            font-size: 1.1rem;
            color: white;
            border-radius: 8px;
            font-family: 'Varela Round', sans-serif;
            font-weight: 700;
            cursor: pointer;
            box-shadow: 0 4px 0 #2980b9;
            transition: all 0.1s;
        }
        .btn-restart:active { transform: translateY(4px); box-shadow: none; }

    </style>
</head>
<body>

    <div id="game-container">
        <div id="header">
            <div class="header-left">
                <svg class="crown-icon" viewBox="0 0 24 24">
                    <path d="M5 16L3 5L8.5 10L12 4L15.5 10L21 5L19 16H5M19 19C19 19.6 18.6 20 18 20H6C5.4 20 5 19.6 5 19V18H19V19Z" />
                </svg>
                <div id="high-score-val">0</div>
            </div>
            <div class="header-center">
                <div id="score">0</div>
            </div>
            <div class="header-right">
                <svg class="settings-icon" viewBox="0 0 24 24">
                    <path d="M12,15.5A3.5,3.5 0 0,1 8.5,12A3.5,3.5 0 0,1 12,8.5A3.5,3.5 0 0,1 15.5,12A3.5,3.5 0 0,1 12,15.5M19.43,12.97C19.47,12.65 19.5,12.33 19.5,12C19.5,11.67 19.47,11.34 19.43,11L21.54,9.37C21.73,9.22 21.78,8.95 21.66,8.73L19.66,5.27C19.54,5.05 19.27,4.96 19.05,5.05L16.56,6.05C16.04,5.66 15.5,5.32 14.87,5.07L14.5,2.42C14.46,2.18 14.25,2 14,2H10C9.75,2 9.54,2.18 9.5,2.42L9.13,5.07C8.5,5.32 7.96,5.66 7.44,6.05L4.95,5.05C4.73,4.96 4.46,5.05 4.34,5.27L2.34,8.73C2.21,8.95 2.27,9.22 2.46,9.37L4.57,11C4.53,11.34 4.5,11.67 4.5,12C4.5,12.33 4.53,12.65 4.57,12.97L2.46,14.63C2.27,14.78 2.21,15.05 2.34,15.27L4.34,18.73C4.46,18.95 4.73,19.03 4.95,18.95L7.44,17.94C7.96,18.34 8.5,18.68 9.13,18.93L9.5,21.58C9.54,21.82 9.75,22 10,22H14C14.25,22 14.46,21.82 14.5,21.58L14.87,18.93C15.5,18.67 16.04,18.34 16.56,17.94L19.05,18.95C19.27,19.03 19.54,18.95 19.66,18.73L21.66,15.27C21.78,15.05 21.73,14.78 21.54,14.63L19.43,12.97Z" />
                </svg>
            </div>
        </div>

        <canvas id="gameCanvas"></canvas>

        <div id="game-over">
            <div class="go-title">Game Over</div>
            <div class="go-score">Score: <span id="final-score">0</span></div>
            <button class="btn-restart" onclick="restartGame()">Try Again</button>
        </div>
    </div>

    <script>
        // --- SES SİSTEMİ ---
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioCtx = new AudioContext();
        
        const Sounds = {
            playTone: (freq, type, duration, vol = 0.1) => {
                if (audioCtx.state === 'suspended') audioCtx.resume();
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
                gain.gain.setValueAtTime(vol, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + duration);
            },
            pop: () => Sounds.playTone(250, 'square', 0.08, 0.06), 
            clear: (combo) => {
                const base = 400 + (combo * 60);
                Sounds.playTone(base, 'sawtooth', 0.1, 0.08);
                setTimeout(() => Sounds.playTone(base + 120, 'sine', 0.2, 0.1), 40);
            },
            gameOver: () => {
                Sounds.playTone(150, 'sawtooth', 0.6, 0.2);
                setTimeout(() => Sounds.playTone(100, 'sawtooth', 1.0, 0.2), 300);
            }
        };

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        const scoreEl = document.getElementById('score');
        const highScoreEl = document.getElementById('high-score-val');
        const gameOverScreen = document.getElementById('game-over');
        const finalScoreEl = document.getElementById('final-score');

        // --- AYARLAR ---
        const GRID_SIZE = 8;
        let CELL_SIZE = 40;
        const GAP = 2; 
        const BOARD_OFFSET_Y = 20;
        
        const COLORS = {
            gridEmpty: '#202a3a', 
            blocks: [
                '#E74C3C', '#F39C12', '#F1C40F', '#2ECC71', 
                '#3498DB', '#9B59B6', '#E67E22', '#1ABC9C'
            ]
        };

        const SHAPES = [
            [[1]], [[1, 1]], [[1], [1]], [[1, 1, 1]], [[1], [1], [1]], 
            [[1, 1], [1, 1]], [[1, 1, 1], [0, 1, 0]], [[0, 1, 0], [1, 1, 1]], 
            [[1, 0], [1, 0], [1, 1]], [[0, 1], [0, 1], [1, 1]], 
            [[1, 1, 0], [0, 1, 1]], [[0, 1, 1], [1, 1, 0]], 
            [[1, 1, 1, 1]], [[1, 1, 1], [1, 0, 0]], [[1, 1, 1], [0, 0, 1]]
        ];

        // --- DURUM YÖNETİMİ ---
        let grid = [];
        let debris = [];
        let floatTexts = []; // Yüzen yazılar için dizi
        let dockPieces = [];
        let draggedPiece = null;
        let score = 0;
        let displayScore = 0; // Ekranda görünen kayan skor
        let highScore = localStorage.getItem('blockBlastProHS') || 0;
        let isGameOver = false;
        let canvasWidth, canvasHeight;
        let boardX, boardY, boardWidth;
        let screenShake = 0;

        function resize() {
            const container = document.getElementById('game-container');
            canvasWidth = container.clientWidth;
            canvasHeight = container.clientHeight;
            
            const dpr = window.devicePixelRatio || 1;
            canvas.width = canvasWidth * dpr;
            canvas.height = canvasHeight * dpr;
            ctx.scale(dpr, dpr);
            canvas.style.width = canvasWidth + 'px';
            canvas.style.height = canvasHeight + 'px';

            const margin = 20;
            const availableWidth = canvasWidth - (margin * 2);
            CELL_SIZE = Math.floor((availableWidth - (GAP * (GRID_SIZE - 1))) / GRID_SIZE);
            boardWidth = (CELL_SIZE * GRID_SIZE) + (GAP * (GRID_SIZE - 1));
            boardX = (canvasWidth - boardWidth) / 2;
            boardY = BOARD_OFFSET_Y;

            updateDockPositions();
        }

        function init() {
            if(audioCtx.state === 'suspended') audioCtx.resume();

            grid = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null));
            score = 0;
            displayScore = 0;
            isGameOver = false;
            debris = [];
            floatTexts = [];
            
            updateUI();
            gameOverScreen.classList.remove('active');
            
            spawnPieces();
            resize();
            requestAnimationFrame(gameLoop);
        }

        function spawnPieces() {
            dockPieces = [];
            for (let i = 0; i < 3; i++) {
                const shape = SHAPES[Math.floor(Math.random() * SHAPES.length)];
                const color = COLORS.blocks[Math.floor(Math.random() * COLORS.blocks.length)];
                dockPieces.push({
                    shape: JSON.parse(JSON.stringify(shape)),
                    color: color,
                    x: 0, y: 0, width: 0, height: 0,
                    scale: 0.6, isDragging: false, targetScale: 0.6,
                    baseX: 0, baseY: 0
                });
            }
            updateDockPositions();
            checkGameOver();
        }

        function updateDockPositions() {
            const dockY = boardY + boardWidth + 40;
            const pieceSpacing = canvasWidth / 3;
            dockPieces.forEach((p, index) => {
                if (!p) return;
                p.baseX = (pieceSpacing * index) + (pieceSpacing / 2);
                p.baseY = dockY + 60;
                if (!p.isDragging) { p.x = p.baseX; p.y = p.baseY; }
            });
        }

        // --- DRAWING FUNCTIONS ---
        function drawBlock(ctx, x, y, size, color, alpha = 1.0, scale = 1.0) {
            ctx.globalAlpha = alpha;
            const center = size/2;
            
            ctx.save();
            ctx.translate(x + center, y + center);
            ctx.scale(scale, scale);
            ctx.translate(-center, -center);

            // Base
            ctx.fillStyle = color;
            ctx.fillRect(0, 0, size, size);

            // Bevel Highlight & Shadow (Classic 3D)
            const bevel = size * 0.15;
            
            ctx.fillStyle = "rgba(255,255,255,0.3)";
            ctx.beginPath();
            ctx.moveTo(0, 0); ctx.lineTo(size, 0); ctx.lineTo(size-bevel, bevel); ctx.lineTo(bevel, bevel); ctx.lineTo(bevel, size-bevel); ctx.lineTo(0, size);
            ctx.fill();

            ctx.fillStyle = "rgba(0,0,0,0.2)";
            ctx.beginPath();
            ctx.moveTo(size, size); ctx.lineTo(0, size); ctx.lineTo(bevel, size-bevel); ctx.lineTo(size-bevel, size-bevel); ctx.lineTo(size-bevel, bevel); ctx.lineTo(size, 0);
            ctx.fill();

            // Inner Face
            ctx.fillStyle = color;
            ctx.fillRect(bevel, bevel, size - bevel*2, size - bevel*2);

            ctx.restore();
            ctx.globalAlpha = 1.0;
        }

        function createFloatingText(text, x, y, color) {
            floatTexts.push({
                text: text,
                x: x, y: y,
                vy: -2, // Yukarı hareket hızı
                life: 1.0,
                color: color
            });
        }

        // --- GAME LOGIC ---

        let isInputDown = false, dragOffsetY = 0;

        function handleInputStart(x, y) {
            if (isGameOver) return;
            if (audioCtx.state === 'suspended') audioCtx.resume();
            
            isInputDown = true;
            for (let p of dockPieces) {
                if (!p) continue;
                if (Math.abs(x - p.x) < 70 && Math.abs(y - p.y) < 70) {
                    draggedPiece = p;
                    draggedPiece.isDragging = true;
                    draggedPiece.targetScale = 1.0; 
                    dragOffsetY = -80;
                    draggedPiece.x = x;
                    draggedPiece.y = y + dragOffsetY;
                    if(navigator.vibrate) navigator.vibrate(10);
                    Sounds.pop();
                    break;
                }
            }
        }

        function handleInputMove(x, y) {
            if (draggedPiece) { draggedPiece.x = x; draggedPiece.y = y + dragOffsetY; }
        }

        function handleInputEnd() {
            if (draggedPiece) {
                const gp = getGridPosFromScreen(draggedPiece.x, draggedPiece.y, draggedPiece.shape);
                if (gp && canPlace(draggedPiece.shape, gp.c, gp.r)) {
                    placePiece(draggedPiece, gp.c, gp.r);
                    const index = dockPieces.indexOf(draggedPiece);
                    dockPieces[index] = null;
                    if(navigator.vibrate) navigator.vibrate(15);
                    if (dockPieces.every(p => p === null)) spawnPieces();
                    else checkGameOver();
                } else {
                    draggedPiece.isDragging = false;
                    draggedPiece.targetScale = 0.6;
                    draggedPiece.x = draggedPiece.baseX;
                    draggedPiece.y = draggedPiece.baseY;
                }
                draggedPiece = null;
            }
            isInputDown = false;
        }

        function getGridPosFromScreen(px, py, shape) {
            const w = shape[0].length * CELL_SIZE;
            const h = shape.length * CELL_SIZE;
            const c = Math.round((px - w/2 - boardX) / (CELL_SIZE + GAP));
            const r = Math.round((py - h/2 - boardY) / (CELL_SIZE + GAP));
            return { c, r };
        }

        function canPlace(shape, c, r) {
            for (let y = 0; y < shape.length; y++) {
                for (let x = 0; x < shape[0].length; x++) {
                    if (shape[y][x] === 1) {
                        const gx = c + x, gy = r + y;
                        if (gx < 0 || gx >= GRID_SIZE || gy < 0 || gy >= GRID_SIZE) return false;
                        if (grid[gy][gx] !== null) return false;
                    }
                }
            }
            return true;
        }

        function placePiece(piece, c, r) {
            let blocksPlaced = 0;
            Sounds.pop();
            screenShake = 2; // Hafif sarsıntı
            
            for (let y = 0; y < piece.shape.length; y++) {
                for (let x = 0; x < piece.shape[0].length; x++) {
                    if (piece.shape[y][x] === 1) {
                        grid[r + y][c + x] = piece.color;
                        blocksPlaced++;
                    }
                }
            }
            
            const points = blocksPlaced * 10;
            addScore(points);
            // Yüzen puan yazısı (Bloğun ortasında çıksın)
            const cx = boardX + (c + piece.shape[0].length/2) * (CELL_SIZE + GAP);
            const cy = boardY + (r + piece.shape.length/2) * (CELL_SIZE + GAP);
            createFloatingText(`+${points}`, cx, cy, '#fff');

            checkLines();
        }

        function checkLines() {
            let linesCleared = [];
            for (let y = 0; y < GRID_SIZE; y++) {
                if (grid[y].every(cell => cell !== null)) linesCleared.push({type:'row', idx:y});
            }
            for (let x = 0; x < GRID_SIZE; x++) {
                let full = true;
                for (let y = 0; y < GRID_SIZE; y++) {
                    if (grid[y][x] === null) { full = false; break; }
                }
                if (full) linesCleared.push({type:'col', idx:x});
            }

            if (linesCleared.length > 0) {
                Sounds.clear(linesCleared.length);
                screenShake = 5 + (linesCleared.length * 3); // Patlatmada daha çok sarsıntı

                linesCleared.forEach(line => {
                    let lx, ly;
                    if(line.type === 'row') {
                        lx = boardX + boardWidth/2;
                        ly = boardY + line.idx * (CELL_SIZE + GAP) + CELL_SIZE/2;
                        for(let x=0; x<GRID_SIZE; x++) {
                            createDebris(x * (CELL_SIZE + GAP) + boardX + CELL_SIZE/2, line.idx * (CELL_SIZE + GAP) + boardY + CELL_SIZE/2, grid[line.idx][x]);
                            grid[line.idx][x] = null;
                        }
                    } else {
                        lx = boardX + line.idx * (CELL_SIZE + GAP) + CELL_SIZE/2;
                        ly = boardY + boardWidth/2;
                        for(let y=0; y<GRID_SIZE; y++) {
                            createDebris(line.idx * (CELL_SIZE + GAP) + boardX + CELL_SIZE/2, y * (CELL_SIZE + GAP) + boardY + CELL_SIZE/2, grid[y][line.idx]);
                            grid[y][line.idx] = null;
                        }
                    }
                });

                let points = linesCleared.length * 100;
                if (linesCleared.length > 1) {
                    points *= 1.5; 
                    createFloatingText("COMBO!", canvasWidth/2, boardY + boardWidth/2, '#f2c94c');
                }
                
                // Patlatma puanını merkeze ekle
                addScore(Math.floor(points));
                createFloatingText(`+${Math.floor(points)}`, canvasWidth/2, boardY + boardWidth/2 - 40, '#f2c94c');

                if(navigator.vibrate) navigator.vibrate(linesCleared.length * 40);
            }
        }

        function checkGameOver() {
            const active = dockPieces.filter(p => p !== null);
            if (active.length === 0) return;
            
            let canMove = false;
            for (let p of active) {
                for (let y = 0; y < GRID_SIZE; y++) {
                    for (let x = 0; x < GRID_SIZE; x++) {
                        if (canPlace(p.shape, x, y)) { canMove = true; break; }
                    }
                    if (canMove) break;
                }
                if (canMove) break;
            }
            if (!canMove) {
                setTimeout(() => {
                    isGameOver = true;
                    Sounds.gameOver();
                    gameOverScreen.classList.add('active');
                    finalScoreEl.innerText = score;
                }, 800);
            }
        }

        function addScore(amt) {
            score += amt;
            if (score > highScore) {
                highScore = score;
                highScoreEl.innerText = highScore;
                localStorage.setItem('blockBlastProHS', highScore);
            }
        }
        
        // Rolling number logic handled in loop
        function updateUI() { 
            // Manual update not needed for scoreEl, done in gameLoop
            highScoreEl.innerText = highScore; 
        }
        function restartGame() { init(); }

        function createDebris(x, y, color) {
            for(let i=0; i<5; i++) {
                debris.push({
                    x: x, y: y,
                    vx: (Math.random()-0.5) * 12,
                    vy: (Math.random()-0.5) * 12,
                    size: Math.random() * 8 + 4,
                    color: color,
                    life: 1.0,
                });
            }
        }

        // --- RENDER DÖNGÜSÜ ---
        function gameLoop() {
            // Screen Shake Logic
            let sx = 0, sy = 0;
            if (screenShake > 0) {
                sx = (Math.random() - 0.5) * screenShake;
                sy = (Math.random() - 0.5) * screenShake;
                screenShake *= 0.9;
                if(screenShake < 0.5) screenShake = 0;
            }

            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            ctx.save();
            ctx.translate(sx, sy);

            // Rolling Number Logic
            if (displayScore < score) {
                let diff = score - displayScore;
                let step = Math.ceil(diff * 0.15); // Hızlıca yaklaş
                if (step < 1) step = 1;
                displayScore += step;
                scoreEl.innerText = displayScore;
            }

            // GRID
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const posX = boardX + x * (CELL_SIZE + GAP);
                    const posY = boardY + y * (CELL_SIZE + GAP);
                    
                    ctx.fillStyle = COLORS.gridEmpty; 
                    ctx.fillRect(posX, posY, CELL_SIZE, CELL_SIZE);

                    if (grid[y][x]) {
                        drawBlock(ctx, posX, posY, CELL_SIZE, grid[y][x]);
                    }
                }
            }

            // GHOST PIECE
            if (draggedPiece) {
                const gp = getGridPosFromScreen(draggedPiece.x, draggedPiece.y, draggedPiece.shape);
                if (gp && canPlace(draggedPiece.shape, gp.c, gp.r)) {
                    ctx.globalAlpha = 0.3;
                    for (let y = 0; y < draggedPiece.shape.length; y++) {
                        for (let x = 0; x < draggedPiece.shape[0].length; x++) {
                            if (draggedPiece.shape[y][x] === 1) {
                                const px = boardX + (gp.c + x) * (CELL_SIZE + GAP);
                                const py = boardY + (gp.r + y) * (CELL_SIZE + GAP);
                                ctx.fillStyle = draggedPiece.color;
                                ctx.fillRect(px, py, CELL_SIZE, CELL_SIZE);
                            }
                        }
                    }
                    ctx.globalAlpha = 1.0;
                }
            }

            // PARTICLES
            for(let i=debris.length-1; i>=0; i--) {
                const p = debris[i];
                p.x += p.vx; p.y += p.vy;
                p.life -= 0.04;
                if(p.life <= 0) { debris.splice(i, 1); continue; }
                
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x, p.y, p.size, p.size);
                ctx.globalAlpha = 1.0;
            }

            // DOCK
            dockPieces.forEach(p => {
                if (!p) return;
                p.scale += (p.targetScale - p.scale) * 0.2;
                const blockSize = draggedPiece === p ? CELL_SIZE : 26;
                const gap = draggedPiece === p ? GAP : 2;
                const totalW = p.shape[0].length * (blockSize + gap);
                const totalH = p.shape.length * (blockSize + gap);
                const startX = p.x - (totalW / 2);
                const startY = p.y - (totalH / 2);

                for (let r = 0; r < p.shape.length; r++) {
                    for (let c = 0; c < p.shape[0].length; c++) {
                        if (p.shape[r][c] === 1) {
                            drawBlock(ctx, startX + c*(blockSize+gap), startY + r*(blockSize+gap), blockSize, p.color, draggedPiece===p?0.9:1.0, 1.0);
                        }
                    }
                }
            });

            // FLOATING TEXTS (Yüzen Puanlar)
            ctx.textAlign = "center";
            ctx.font = "bold 24px 'Varela Round', sans-serif";
            for(let i=floatTexts.length-1; i>=0; i--) {
                const ft = floatTexts[i];
                ft.y += ft.vy;
                ft.life -= 0.02;
                if(ft.life <= 0) { floatTexts.splice(i, 1); continue; }
                
                ctx.globalAlpha = ft.life;
                ctx.fillStyle = ft.color;
                // Text outline
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                ctx.strokeText(ft.text, ft.x, ft.y);
                ctx.fillText(ft.text, ft.x, ft.y);
                ctx.globalAlpha = 1.0;
            }

            ctx.restore();
            requestAnimationFrame(gameLoop);
        }

        // --- EVENTS ---
        window.addEventListener('resize', resize);
        
        canvas.addEventListener('mousedown', e => handleInputStart(e.offsetX, e.offsetY));
        window.addEventListener('mousemove', e => { if(isInputDown) {
            const r = canvas.getBoundingClientRect();
            handleInputMove(e.clientX - r.left, e.clientY - r.top);
        }});
        window.addEventListener('mouseup', handleInputEnd);

        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            const r = canvas.getBoundingClientRect();
            handleInputStart(e.touches[0].clientX - r.left, e.touches[0].clientY - r.top);
        }, {passive: false});
        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            if(isInputDown) {
                const r = canvas.getBoundingClientRect();
                handleInputMove(e.touches[0].clientX - r.left, e.touches[0].clientY - r.top);
            }
        }, {passive: false});
        window.addEventListener('touchend', handleInputEnd);

        window.onload = init;

    </script>
</body>
</html>