<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Block Blast - Pastel Edition</title>
    <style>
        /* Daha yuvarlak ve sevimli bir font seçelim (Fredoka zaten iyiydi, koruyoruz) */
        @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;700;900&display=swap');

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            /* Arka planı aydınlık pastel bir geçiş yapalım */
            background: linear-gradient(135deg, #fdfcfb 0%, #e2d1c3 100%);
            font-family: 'Fredoka', sans-serif;
            touch-action: none;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: 500px;
            /* Oyun alanı arka planı daha yumuşak, sütlü bir görünüm */
            background: rgba(255, 255, 255, 0.4);
            display: flex;
            flex-direction: column;
            align-items: center;
            /* Koyu gölge yerine yumuşak bir ışık huzmesi */
            box-shadow: 0 10px 30px rgba(0,0,0,0.05), inset 0 0 20px rgba(255,255,255,0.5);
            border-radius: 24px; /* Konteyner köşeleri daha yuvarlak */
            border: 2px solid rgba(255, 255, 255, 0.6);
        }

        /* --- UI --- */
        #header {
            width: 88%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-top: 40px;
            padding-bottom: 10px;
            z-index: 10;
        }

        .score-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .score-box {
            /* Kutular artık açık renkli, süt beyazı */
            background: rgba(255, 255, 255, 0.7);
            padding: 8px 20px;
            border-radius: 20px; /* Daha yuvarlak */
            text-align: left;
            border: 2px solid rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.05);
            min-width: 100px;
            transition: transform 0.1s;
        }

        .score-label {
            /* Etiket rengi yumuşak gri/leylak */
            color: #9ba4b4;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            font-weight: 700;
        }

        .score-val {
            /* Skor değeri koyu pastel bir renk */
            color: #5e6c84;
            font-size: 1.6rem;
            font-weight: 900;
            text-shadow: none; /* Neon gölgeyi kaldırdık */
        }

        #high-score-val { color: #ffb347; /* Pastel turuncu */ }
        #score.pop { animation: scorePop 0.2s ease-out; }

        @keyframes scorePop {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); color: #ff8fab; } /* Pembemsi pop efekti */
            100% { transform: scale(1); }
        }

        canvas {
            display: block;
            border-radius: 24px;
            z-index: 5;
            /* Canvas gölgesini yumuşattık */
            filter: drop-shadow(0 5px 15px rgba(0,0,0,0.1));
            touch-action: none;
            margin-top: 10px;
        }

        /* --- CONTROLS --- */
        #controls-area {
            position: absolute;
            bottom: 30px;
            right: 20px;
            z-index: 15;
        }

        .btn-icon {
            /* Butonlar da açık renkli ve yumuşak */
            background: rgba(255, 255, 255, 0.8);
            border: 2px solid #fff;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            color: #7a8ba3; /* İkon rengi pastel mavi/gri */
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0,0,0,0.08);
            transition: all 0.2s ease;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .btn-icon:hover { background: #fff; transform: scale(1.1); color: #ff8fab; }
        .btn-icon:active { transform: scale(0.95); }

        /* --- GAME OVER --- */
        #game-over {
            position: absolute;
            inset: 0;
            /* Oyun bitiş ekranı aydınlık, buzlu cam gibi */
            background: rgba(255, 255, 255, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            opacity: 0;
            pointer-events: none;
            transform: scale(0.9);
            transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            backdrop-filter: blur(15px);
            border-radius: 24px;
        }

        #game-over.active { opacity: 1; pointer-events: all; transform: scale(1); }

        .go-title {
            font-size: 3rem;
            /* Başlık rengi pastel gradyan */
            background: linear-gradient(45deg, #ff8fab, #ffc8dd, #bde0fe);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 5px;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: -1px;
             /* Yumuşak bir gölge ekleyelim okunsun diye */
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));
        }

        .go-score {
            font-size: 1.5rem;
            color: #9ba4b4;
            margin-bottom: 40px;
            font-weight: 600;
        }
        
        .go-score span { color: #5e6c84; font-size: 2rem; font-weight: 800; }

        .btn-restart {
            /* Yeniden başlat butonu şeker gibi */
            background: linear-gradient(90deg, #a2d2ff 0%, #bde0fe 100%);
            border: none;
            padding: 20px 60px;
            font-size: 1.2rem;
            color: white;
            border-radius: 50px;
            font-family: 'Fredoka', sans-serif;
            font-weight: 800;
            cursor: pointer;
            box-shadow: 0 5px 20px rgba(162, 210, 255, 0.5);
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
            position: relative;
            overflow: hidden;
        }
        
        .btn-restart:hover { box-shadow: 0 8px 25px rgba(162, 210, 255, 0.7); transform: translateY(-2px); }
        .btn-restart:active { transform: scale(0.95) translateY(0); }

    </style>
</head>
<body>

    <div id="game-container">
        <div id="header">
            <div class="score-group">
                <div class="score-box">
                    <div class="score-label">Skor</div>
                    <div class="score-val" id="score">0</div>
                </div>
            </div>
            <div class="score-group">
                <div class="score-box" style="border-color: rgba(255, 179, 71, 0.4);">
                    <div class="score-label" style="color: #ffc8dd;">Rekor</div>
                    <div class="score-val" id="high-score-val">0</div>
                </div>
            </div>
        </div>

        <canvas id="gameCanvas"></canvas>

        <div id="controls-area">
            <button class="btn-icon" id="btn-rotate" onclick="rotateDockPieces()" title="Parçaları Döndür">
                <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M2.5 2v6h6M21.5 22v-6h-6"/><path d="M22 11.5A10 10 0 0 0 3.2 7.2M2 12.5a10 10 0 0 0 18.8 4.2"/>
                </svg>
            </button>
        </div>

        <div id="game-over">
            <div class="go-title">OYUN BİTTİ</div>
            <div class="go-score">SKORUN: <span id="final-score">0</span></div>
            <button class="btn-restart" onclick="restartGame()">TEKRAR OYNA</button>
        </div>
    </div>

    <script>
        // --- SES SİSTEMİ (Daha yumuşak tonlar için ayarlandı) ---
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioCtx = new AudioContext();
        
        const Sounds = {
            playTone: (freq, type, duration, vol = 0.1) => {
                if (audioCtx.state === 'suspended') audioCtx.resume();
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
                gain.gain.setValueAtTime(vol, audioCtx.currentTime);
                // Sesi daha yumuşak kesmek için exponential yerine linear ramp
                gain.gain.linearRampToValueAtTime(0.001, audioCtx.currentTime + duration);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + duration);
            },
            
            pop: () => { // Blok yerleştirme sesi - daha yumuşak 'sine' dalgası
                Sounds.playTone(300 + Math.random()*100, 'sine', 0.15, 0.08);
            },
            
            rotate: () => { // Döndürme sesi
                Sounds.playTone(500, 'sine', 0.1, 0.05);
            },

            clear: (combo) => { // Patlama sesi - 'triangle' daha az agresif
                const base = 300 + (combo * 80);
                Sounds.playTone(base, 'triangle', 0.2, 0.1);
                setTimeout(() => Sounds.playTone(base * 1.3, 'sine', 0.25, 0.08), 80);
            },
            
            gameOver: () => { // Oyun bitiş
                Sounds.playTone(200, 'triangle', 0.8, 0.1);
                setTimeout(() => Sounds.playTone(150, 'triangle', 1.0, 0.1), 300);
            }
        };

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        const scoreEl = document.getElementById('score');
        const highScoreEl = document.getElementById('high-score-val');
        const gameOverScreen = document.getElementById('game-over');
        const finalScoreEl = document.getElementById('final-score');
        const gameContainer = document.getElementById('game-container');

        // --- AYARLAR ---
        const GRID_SIZE = 8;
        let CELL_SIZE = 40;
        const GAP = 6; // Boşlukları biraz artırdık, daha ferah görünsün
        const BOARD_OFFSET_Y = 60;
        
        // Arka plan için pastel renk döngüsü
        let bgHue = 0; 

        // --- YENİ PASTEL RENK PALETİ ---
        const COLORS = {
            gridEmpty: '#f0f4f8', // Çok açık gri/mavi (süt gibi)
            gridBorder: '#e1e8ed', // Biraz daha koyusu
            // Pastel Blok Renkleri (Macaron tonları)
            blocks: [
                '#ffadad', // Pastel Kırmızı (Somon)
                '#ffd6a5', // Pastel Turuncu (Şeftali)
                '#fdffb6', // Pastel Sarı (Krem Limon)
                '#caffbf', // Pastel Yeşil (Nane)
                '#9bf6ff', // Pastel Açık Mavi (Buz Mavisi)
                '#a0c4ff', // Pastel Mavi (Gök Mavisi)
                '#bdb2ff', // Pastel Mor (Leylak)
                '#ffc6ff'  // Pastel Pembe (Şeker Pembe)
            ]
        };

        const SHAPES = [
            [[1]], [[1, 1]], [[1], [1]], [[1, 1, 1]], [[1], [1], [1]], 
            [[1, 1], [1, 1]], [[1, 1, 1], [0, 1, 0]], [[0, 1, 0], [1, 1, 1]], 
            [[1, 0], [1, 0], [1, 1]], [[0, 1], [0, 1], [1, 1]], 
            [[1, 1, 0], [0, 1, 1]], [[0, 1, 1], [1, 1, 0]], 
            [[1, 1, 1, 1]], [[1, 1, 1], [1, 0, 0]], [[1, 1, 1], [0, 0, 1]]
        ];

        // --- DURUM YÖNETİMİ ---
        let grid = [];
        let particles = [], debris = [], popups = [], shockwaves = [], flashes = [], confettis = [];
        let dockPieces = [];
        let draggedPiece = null;
        let score = 0;
        let highScore = localStorage.getItem('blockBlastPastelHighScore') || 0;
        let isGameOver = false;
        let comboCount = 0;
        let lastClearTime = 0;
        let canvasWidth, canvasHeight;
        let boardX, boardY, boardWidth;
        let screenShake = 0;
        let isNewHighScore = false;

        function resize() {
            const container = document.getElementById('game-container');
            canvasWidth = container.clientWidth;
            canvasHeight = container.clientHeight;
            
            const dpr = window.devicePixelRatio || 1;
            canvas.width = canvasWidth * dpr;
            canvas.height = canvasHeight * dpr;
            ctx.scale(dpr, dpr);
            canvas.style.width = canvasWidth + 'px';
            canvas.style.height = canvasHeight + 'px';

            const margin = 20;
            const availableWidth = canvasWidth - (margin * 2);
            CELL_SIZE = Math.floor((availableWidth - (GAP * (GRID_SIZE - 1))) / GRID_SIZE);
            boardWidth = (CELL_SIZE * GRID_SIZE) + (GAP * (GRID_SIZE - 1));
            boardX = (canvasWidth - boardWidth) / 2;
            boardY = BOARD_OFFSET_Y + 50;

            updateDockPositions();
        }

        function init() {
            if(audioCtx.state === 'suspended') audioCtx.resume();

            grid = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null));
            score = 0;
            isGameOver = false;
            particles = []; debris = []; popups = []; shockwaves = []; flashes = []; confettis = [];
            comboCount = 0;
            isNewHighScore = false;
            
            updateUI();
            gameOverScreen.classList.remove('active');
            
            spawnPieces();
            resize();
            requestAnimationFrame(gameLoop);
        }

        function spawnPieces() {
            dockPieces = [];
            for (let i = 0; i < 3; i++) {
                const shape = SHAPES[Math.floor(Math.random() * SHAPES.length)];
                const color = COLORS.blocks[Math.floor(Math.random() * COLORS.blocks.length)];
                dockPieces.push({
                    shape: JSON.parse(JSON.stringify(shape)),
                    color: color,
                    x: 0, y: 0, width: 0, height: 0,
                    scale: 0.6, isDragging: false, targetScale: 0.6,
                    baseX: 0, baseY: 0
                });
            }
            updateDockPositions();
            checkGameOver();
        }

        function updateDockPositions() {
            const dockY = boardY + boardWidth + 40;
            const pieceSpacing = canvasWidth / 3;
            dockPieces.forEach((p, index) => {
                if (!p) return;
                p.baseX = (pieceSpacing * index) + (pieceSpacing / 2);
                p.baseY = dockY + 50;
                if (!p.isDragging) { p.x = p.baseX; p.y = p.baseY; }
            });
        }

        function rotateMatrix(matrix) {
            const N = matrix.length;
            const M = matrix[0].length;
            let result = Array(M).fill().map(() => Array(N).fill(0));
            for(let i=0; i<N; i++) {
                for(let j=0; j<M; j++) {
                    result[j][N - 1 - i] = matrix[i][j];
                }
            }
            return result;
        }

        function rotateDockPieces() {
            if(isGameOver) return;
            let rotatedAny = false;
            dockPieces.forEach(p => {
                if(p && !p.isDragging) {
                    p.shape = rotateMatrix(p.shape);
                    p.scale = 0.1; 
                    p.targetScale = 0.6;
                    // Dönme efekti için beyaz yerine pastel sarı partikül
                    createParticles(p.x, p.y, '#fdffb6', 3, 2);
                    rotatedAny = true;
                }
            });
            if(rotatedAny) {
                Sounds.rotate();
                checkGameOver();
            }
        }

        window.addEventListener('keydown', (e) => {
            if((e.key === 'r' || e.key === 'R') && !isGameOver) {
                rotateDockPieces();
            }
        });

        // --- GÖRSEL FONKSİYONLAR (YENİLENMİŞ PASTEL BLOK ÇİZİMİ) ---
        
        // Yardımcı fonksiyon: Rengi açmak/koyulaştırmak için
        function adjustColor(color, amount) {
            return '#' + color.replace(/^#/, '').replace(/../g, color => ('0'+Math.min(255, Math.max(0, parseInt(color, 16) + amount)).toString(16)).substr(-2));
        }

        // Yeni "Şirin" Blok Çizimi
        function drawBlock(ctx, x, y, size, color, alpha = 1.0, scale = 1.0) {
            ctx.globalAlpha = alpha;
            const center = size/2;
            // Daha büyük yarıçap = daha yuvarlak, yumuşak bloklar
            const r = 12 * scale; 
            
            ctx.save();
            ctx.translate(x + center, y + center);
            ctx.scale(scale, scale);
            ctx.translate(-center, -center);

            // 1. Ana Renk (Mat, düz pastel dolgu)
            ctx.fillStyle = color;
            // Çizgiyi (stroke) kaldırdık, daha yumuşak görünsün
            ctx.beginPath();
            if(ctx.roundRect) ctx.roundRect(0, 0, size, size, r);
            else ctx.rect(0, 0, size, size);
            ctx.fill();

            // 2. Alt Kısım Gölgesi (Sert siyah yerine, rengin koyu tonu)
            const darkerColor = adjustColor(color, -40); // Rengin 40 birim koyusu
            ctx.fillStyle = darkerColor;
            ctx.beginPath();
            // Alt tarafa hafif bir kalınlık hissi veren yumuşak gölge
            ctx.moveTo(r, size); 
            ctx.lineTo(size - r, size);
            ctx.quadraticCurveTo(size, size, size, size - r);
            ctx.lineTo(size, size - 4);
            ctx.quadraticCurveTo(size, size - 4, size - r, size - 4);
            ctx.lineTo(r, size - 4);
            ctx.quadraticCurveTo(0, size - 4, 0, size - r - 4);
            ctx.lineTo(0, size - r);
            ctx.quadraticCurveTo(0, size, r, size);
            ctx.fill();

            // 3. Üst Kısım Parlaması (Keskin beyaz yerine, yumuşak açık ton)
            const lighterColor = adjustColor(color, 30); // Rengin 30 birim açığı
            ctx.fillStyle = lighterColor;
             ctx.beginPath();
             // Üst tarafa hafif bir "tomruluk" hissi veren oval parlama
            ctx.ellipse(size/2, size/4, size/2.5, size/6, 0, 0, Math.PI*2);
            ctx.fill();

            ctx.restore();
            ctx.globalAlpha = 1.0;
        }

        function drawRoundedRect(ctx, x, y, w, h, r) {
            ctx.beginPath();
            if(ctx.roundRect) ctx.roundRect(x, y, w, h, r);
            else ctx.rect(x, y, w, h);
            ctx.fill();
            // Kenar çizgilerini kaldırdık, daha temiz bir görüntü için
            // ctx.stroke(); 
        }

        // --- OYUN MANTIĞI (Değişiklik yok, sadece ses çağrıları güncellendi) ---

        let isInputDown = false, dragOffsetY = 0;

        function handleInputStart(x, y) {
            if (isGameOver) return;
            if (audioCtx.state === 'suspended') audioCtx.resume();
            
            isInputDown = true;
            for (let p of dockPieces) {
                if (!p) continue;
                if (Math.abs(x - p.x) < 70 && Math.abs(y - p.y) < 70) {
                    draggedPiece = p;
                    draggedPiece.isDragging = true;
                    draggedPiece.targetScale = 1.1; 
                    dragOffsetY = -100;
                    draggedPiece.x = x;
                    draggedPiece.y = y + dragOffsetY;
                    if(navigator.vibrate) navigator.vibrate(10);
                    Sounds.pop();
                    break;
                }
            }
        }

        function handleInputMove(x, y) {
            if (draggedPiece) { draggedPiece.x = x; draggedPiece.y = y + dragOffsetY; }
        }

        function handleInputEnd() {
            if (draggedPiece) {
                const gp = getGridPosFromScreen(draggedPiece.x, draggedPiece.y, draggedPiece.shape);
                if (gp && canPlace(draggedPiece.shape, gp.c, gp.r)) {
                    placePiece(draggedPiece, gp.c, gp.r);
                    const index = dockPieces.indexOf(draggedPiece);
                    dockPieces[index] = null;
                    if(navigator.vibrate) navigator.vibrate(20);
                    if (dockPieces.every(p => p === null)) spawnPieces();
                    else checkGameOver();
                } else {
                    draggedPiece.isDragging = false;
                    draggedPiece.targetScale = 0.6;
                    draggedPiece.x = draggedPiece.baseX;
                    draggedPiece.y = draggedPiece.baseY;
                    // Bırakma sesi daha yumuşak
                    Sounds.playTone(150, 'sine', 0.1, 0.05); 
                }
                draggedPiece = null;
            }
            isInputDown = false;
        }

        function getGridPosFromScreen(px, py, shape) {
            const w = shape[0].length * CELL_SIZE;
            const h = shape.length * CELL_SIZE;
            const c = Math.round((px - w/2 - boardX) / (CELL_SIZE + GAP));
            const r = Math.round((py - h/2 - boardY) / (CELL_SIZE + GAP));
            return { c, r };
        }

        function canPlace(shape, c, r) {
            for (let y = 0; y < shape.length; y++) {
                for (let x = 0; x < shape[0].length; x++) {
                    if (shape[y][x] === 1) {
                        const gx = c + x, gy = r + y;
                        if (gx < 0 || gx >= GRID_SIZE || gy < 0 || gy >= GRID_SIZE) return false;
                        if (grid[gy][gx] !== null) return false;
                    }
                }
            }
            return true;
        }

        function placePiece(piece, c, r) {
            let blocksPlaced = 0;
            screenShake = 3; // Titreşimi azalttık, daha nazik olsun
            Sounds.pop();
            
            for (let y = 0; y < piece.shape.length; y++) {
                for (let x = 0; x < piece.shape[0].length; x++) {
                    if (piece.shape[y][x] === 1) {
                        grid[r + y][c + x] = piece.color;
                        createParticles(
                            (c + x) * (CELL_SIZE + GAP) + boardX + CELL_SIZE/2,
                            (r + y) * (CELL_SIZE + GAP) + boardY + CELL_SIZE/2,
                            piece.color, 5, 3
                        );
                        blocksPlaced++;
                    }
                }
            }
            addScore(blocksPlaced * 10);
            checkLines();
        }

        function checkLines() {
            let linesCleared = [];
            for (let y = 0; y < GRID_SIZE; y++) {
                if (grid[y].every(cell => cell !== null)) linesCleared.push({type:'row', idx:y});
            }
            for (let x = 0; x < GRID_SIZE; x++) {
                let full = true;
                for (let y = 0; y < GRID_SIZE; y++) {
                    if (grid[y][x] === null) { full = false; break; }
                }
                if (full) linesCleared.push({type:'col', idx:x});
            }

            if (linesCleared.length > 0) {
                const now = Date.now();
                comboCount = (now - lastClearTime < 5000) ? comboCount + 1 : 1;
                lastClearTime = now;
                
                Sounds.clear(comboCount);

                screenShake = 8 + (linesCleared.length * 2); // Titreşim azaldı
                // Şok dalgası rengi beyaz yerine çok açık sarı
                shockwaves.push({ x: canvasWidth/2, y: boardY + boardWidth/2, r: 0, alpha: 0.6, color: '#ffffd1', lw: 20 });
                
                // Arka plan rengini pastel döngüde değiştir
                bgHue = (bgHue + 40) % 360;

                linesCleared.forEach(line => {
                    if(line.type === 'row') {
                        // Flash rengi yumuşak beyaz
                        flashes.push({ x: boardX, y: boardY + line.idx * (CELL_SIZE + GAP), w: boardWidth, h: CELL_SIZE, life: 0.8 });
                        for(let x=0; x<GRID_SIZE; x++) {
                            const cx = x * (CELL_SIZE + GAP) + boardX + CELL_SIZE/2;
                            const cy = line.idx * (CELL_SIZE + GAP) + boardY + CELL_SIZE/2;
                            createDebris(cx, cy, grid[line.idx][x]);
                            grid[line.idx][x] = null;
                        }
                    } else {
                        flashes.push({ x: boardX + line.idx * (CELL_SIZE + GAP), y: boardY, w: CELL_SIZE, h: boardWidth, life: 0.8 });
                        for(let y=0; y<GRID_SIZE; y++) {
                            const cx = line.idx * (CELL_SIZE + GAP) + boardX + CELL_SIZE/2;
                            const cy = y * (CELL_SIZE + GAP) + boardY + CELL_SIZE/2;
                            createDebris(cx, cy, grid[y][line.idx]);
                            grid[y][line.idx] = null;
                        }
                    }
                });

                let points = linesCleared.length * 100;
                if (linesCleared.length > 1) points *= 1.5;
                if (comboCount > 1) {
                    points += (comboCount * 50);
                    // Combo yazısı rengi pastel sarı
                    createPopup(`COMBO x${comboCount}`, canvasWidth/2, boardY + boardWidth/2, '#fdffb6', 1.5 + (comboCount*0.1));
                } else if (linesCleared.length > 1) {
                    // Harika yazısı rengi pastel mavi
                    createPopup("HARİKA!", canvasWidth/2, boardY + boardWidth/2, '#a0c4ff', 1.2);
                }

                addScore(Math.floor(points));
                if(navigator.vibrate) navigator.vibrate(linesCleared.length * 40);
            } else {
                comboCount = 0;
            }
        }

        function checkGameOver() {
            const active = dockPieces.filter(p => p !== null);
            if (active.length === 0) return;
            
            let canMove = false;
            for (let p of active) {
                for (let y = 0; y < GRID_SIZE; y++) {
                    for (let x = 0; x < GRID_SIZE; x++) {
                        if (canPlace(p.shape, x, y)) { canMove = true; break; }
                    }
                    if (canMove) break;
                }
                if (canMove) break;
            }
            if (!canMove) {
                setTimeout(() => {
                    isGameOver = true;
                    Sounds.gameOver();
                    gameOverScreen.classList.add('active');
                    finalScoreEl.innerText = score;
                }, 800);
            }
        }

        function addScore(amt) {
            score += amt;
            scoreEl.innerText = score;
            scoreEl.classList.remove('pop');
            void scoreEl.offsetWidth; 
            scoreEl.classList.add('pop');
            
            if (score > highScore) {
                highScore = score;
                highScoreEl.innerText = highScore;
                localStorage.setItem('blockBlastPastelHighScore', highScore);
                if (!isNewHighScore) {
                    isNewHighScore = true;
                    createConfetti();
                    // Rekor yazısı pastel pembe
                    createPopup("YENİ REKOR!", canvasWidth/2, 100, '#ffc6ff', 2.0);
                }
            }
        }
        function updateUI() { scoreEl.innerText = score; highScoreEl.innerText = highScore; }
        function restartGame() { init(); }

        // --- PARTİKÜL SİSTEMİ (Pastel renkler) ---
        function createDebris(x, y, color) {
            for(let i=0; i<4; i++) {
                debris.push({
                    x: x + (Math.random()-0.5)*20,
                    y: y + (Math.random()-0.5)*20,
                    vx: (Math.random()-0.5) * 8, // Hızları azalttık, daha yavaş süzülsünler
                    vy: (Math.random() * -8) - 4,
                    size: Math.random() * 8 + 6, // Parçalar biraz daha büyük ve tombul
                    color: color,
                    life: 1.0,
                    gravity: 0.6 // Yerçekimi azaldı
                });
            }
        }

        function createParticles(x, y, color, amount, speedBase) {
            for (let i = 0; i < amount; i++) {
                particles.push({
                    x: x, y: y,
                    vx: (Math.random()-0.5)*speedBase*1.5,
                    vy: (Math.random()-0.5)*speedBase*1.5,
                    life: 1.0,
                    color: color,
                    size: Math.random() * 5 + 3
                });
            }
        }

        function createConfetti() {
            for(let i=0; i<60; i++) {
                // Konfetiler için pastel HSL renkleri
                const pastelHue = Math.random() * 360;
                confettis.push({
                    x: canvasWidth/2, y: canvasHeight/2,
                    vx: (Math.random()-0.5)*25,
                    vy: (Math.random()-0.5)*25 - 12,
                    color: `hsl(${pastelHue}, 70%, 80%)`, // Yüksek parlaklık, düşük doygunluk
                    life: 2.5, size: 10
                });
            }
        }

        function createPopup(text, x, y, color, scale=1.0) {
            popups.push({ text, x, y, life: 1.0, color, scale, dy: -1.5 });
        }

        // --- RENDER DÖNGÜSÜ ---
        function gameLoop() {
            // Dinamik ama çok yumuşak arka plan geçişi (Pastel gökyüzü gibi)
            bgHue += 0.2;
            const bgGradient = ctx.createLinearGradient(0, 0, 0, canvasHeight);
            bgGradient.addColorStop(0, `hsl(${bgHue}, 60%, 95%)`); // Çok açık pastel üst
            bgGradient.addColorStop(1, `hsl(${(bgHue+60)%360}, 60%, 90%)`); // Biraz daha koyu pastel alt
            ctx.fillStyle = bgGradient;
            // ctx.fillRect(0, 0, canvasWidth, canvasHeight); // Canvas arka planını kapattık, CSS body hallediyor.
            ctx.clearRect(0,0, canvasWidth, canvasHeight); // Tuvali temizle

            let sx = 0, sy = 0;
            if (screenShake > 0) {
                sx = (Math.random()-0.5)*screenShake;
                sy = (Math.random()-0.5)*screenShake;
                screenShake *= 0.9;
                if (screenShake < 0.5) screenShake = 0;
            }
            ctx.save();
            ctx.translate(sx, sy);

            // GRID Çizimi (Daha yuvarlak köşeler)
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const posX = boardX + x * (CELL_SIZE + GAP);
                    const posY = boardY + y * (CELL_SIZE + GAP);
                    ctx.fillStyle = COLORS.gridEmpty;
                    // Grid yuvaları daha yuvarlak (12px radius)
                    drawRoundedRect(ctx, posX, posY, CELL_SIZE, CELL_SIZE, 12);
                    if (grid[y][x]) {
                        drawBlock(ctx, posX, posY, CELL_SIZE, grid[y][x]);
                    }
                }
            }

            // ÖNİZLEME (Daha yumuşak gölge)
            if (draggedPiece) {
                const gp = getGridPosFromScreen(draggedPiece.x, draggedPiece.y, draggedPiece.shape);
                if (gp && canPlace(draggedPiece.shape, gp.c, gp.r)) {
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = draggedPiece.color; // Kendi renginde yumuşak gölge
                    ctx.globalAlpha = 0.5; // Daha şeffaf
                    for (let y = 0; y < draggedPiece.shape.length; y++) {
                        for (let x = 0; x < draggedPiece.shape[0].length; x++) {
                            if (draggedPiece.shape[y][x] === 1) {
                                const px = boardX + (gp.c + x) * (CELL_SIZE + GAP);
                                const py = boardY + (gp.r + y) * (CELL_SIZE + GAP);
                                ctx.fillStyle = draggedPiece.color;
                                drawRoundedRect(ctx, px, py, CELL_SIZE, CELL_SIZE, 12);
                            }
                        }
                    }
                    ctx.globalAlpha = 1.0;
                    ctx.shadowBlur = 0;
                }
            }

            // EFEKTLER (Flash daha yumuşak)
            flashes.forEach((f, i) => {
                ctx.fillStyle = `rgba(255,255,255,${f.life * 0.6})`; // Daha az opak
                // 'overlay' yerine normal çizim, gözü yormasın
                drawRoundedRect(ctx, f.x, f.y, f.w, f.h, 12);
                f.life -= 0.1;
                if (f.life <= 0) flashes.splice(i, 1);
            });

            // Debris (Parçacıklar) - Dönme efekti kaldırıldı, daha "puf" gibi süzülsünler
            for(let i=debris.length-1; i>=0; i--) {
                const p = debris[i];
                p.x += p.vx; p.y += p.vy; p.vy += p.gravity;
                if (p.y > canvasHeight - 10) { p.y = canvasHeight - 10; p.vy *= -0.5; }
                p.life -= 0.02;
                if(p.life <= 0) { debris.splice(i, 1); continue; }
                
                // Düz renk yerine hafif şeffaf daireler
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size/2, 0, Math.PI*2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }

            // Şok Dalgaları (Daha kalın ve yumuşak)
            for(let i=shockwaves.length-1; i>=0; i--) {
                const sw = shockwaves[i];
                sw.r += 8; sw.alpha -= 0.03;
                if(sw.alpha <= 0) { shockwaves.splice(i, 1); continue; }
                ctx.beginPath(); ctx.arc(sw.x, sw.y, sw.r, 0, Math.PI*2);
                ctx.strokeStyle = sw.color;
                ctx.globalAlpha = sw.alpha;
                ctx.lineWidth = sw.lw; ctx.stroke();
                ctx.globalAlpha = 1.0;
            }

            // Dock Parçaları
            dockPieces.forEach(p => {
                if (!p) return;
                p.scale += (p.targetScale - p.scale) * 0.2;
                const blockSize = draggedPiece === p ? CELL_SIZE : 24;
                const gap = draggedPiece === p ? GAP : 3;
                const totalW = p.shape[0].length * (blockSize + gap);
                const totalH = p.shape.length * (blockSize + gap);
                const startX = p.x - (totalW / 2);
                const startY = p.y - (totalH / 2);

                // Sürüklenirken hafif bir parlama
                if (draggedPiece === p) { ctx.shadowColor = p.color; ctx.shadowBlur = 15; }

                for (let r = 0; r < p.shape.length; r++) {
                    for (let c = 0; c < p.shape[0].length; c++) {
                        if (p.shape[r][c] === 1) {
                            if (draggedPiece === p) {
                                drawBlock(ctx, startX + c*(blockSize+gap), startY + r*(blockSize+gap), blockSize, p.color, 0.95, 1.0);
                            } else {
                                // Dock'taki küçük parçalar da yeni stilde
                                drawBlock(ctx, startX + c*(blockSize+gap), startY + r*(blockSize+gap), blockSize, p.color, 1.0, 1.0);
                            }
                        }
                    }
                }
                ctx.shadowBlur = 0;
            });

            // Popup Yazılar (Neon efekt kaldırıldı, yumuşak gölge eklendi)
            ctx.textAlign = "center";
            for(let i=popups.length-1; i>=0; i--) {
                const p = popups[i];
                p.life -= 0.015; p.y += p.dy; p.scale += 0.005;
                if(p.life <= 0) { popups.splice(i, 1); continue; }
                ctx.save(); ctx.translate(p.x, p.y); ctx.scale(p.scale, p.scale);
                ctx.fillStyle = p.color; ctx.font = "900 40px 'Fredoka', sans-serif";
                // Yumuşak, bulanık gölge
                ctx.shadowColor = "rgba(0,0,0,0.1)"; ctx.shadowBlur = 4; ctx.shadowOffsetY = 4;
                ctx.fillText(p.text, 0, 0);
                // Beyaz kenar çizgisi yerine daha kalın, aynı rengin açığı
                ctx.shadowBlur = 0; ctx.shadowOffsetY = 0;
                ctx.strokeStyle = adjustColor(p.color, 40); ctx.lineWidth = 3; ctx.strokeText(p.text, 0, 0);
                ctx.restore();
            }

            // Konfeti (Kare yerine yuvarlak)
            for(let i=confettis.length-1; i>=0; i--) {
                const c = confettis[i];
                c.x += c.vx; c.y += c.vy; c.vy += 0.4; c.vx *= 0.99; c.life -= 0.015;
                if(c.life <= 0) { confettis.splice(i, 1); continue; }
                ctx.globalAlpha = c.life;
                ctx.fillStyle = c.color;
                ctx.beginPath();
                ctx.arc(c.x, c.y, c.size/2, 0, Math.PI*2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }

            ctx.restore();
            requestAnimationFrame(gameLoop);
        }

        // --- EVENTS (Aynı) ---
        window.addEventListener('resize', resize);
        
        canvas.addEventListener('mousedown', e => handleInputStart(e.offsetX, e.offsetY));
        window.addEventListener('mousemove', e => { if(isInputDown) {
            const r = canvas.getBoundingClientRect();
            handleInputMove(e.clientX - r.left, e.clientY - r.top);
        }});
        window.addEventListener('mouseup', handleInputEnd);

        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            const r = canvas.getBoundingClientRect();
            handleInputStart(e.touches[0].clientX - r.left, e.touches[0].clientY - r.top);
        }, {passive: false});
        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            if(isInputDown) {
                const r = canvas.getBoundingClientRect();
                handleInputMove(e.touches[0].clientX - r.left, e.touches[0].clientY - r.top);
            }
        }, {passive: false});
        window.addEventListener('touchend', handleInputEnd);

        window.onload = init;

    </script>
</body>
</html>